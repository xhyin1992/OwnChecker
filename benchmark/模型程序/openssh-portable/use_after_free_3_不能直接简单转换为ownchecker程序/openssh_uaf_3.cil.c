/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 196 "../stdio.h"
typedef unsigned int u_int___0;
#line 200 "../stdio.h"
typedef int int32_t___0;
#line 207 "../stdio.h"
typedef unsigned char u_char___0;
#line 364 "../openssh.h"
typedef u_int___0 BN_ULONG;
#line 365 "../openssh.h"
struct __anonstruct_Buffer_25 {
   u_char___0 *buf ;
   u_int___0 alloc ;
   u_int___0 offset ;
   u_int___0 end ;
};
#line 365 "../openssh.h"
typedef struct __anonstruct_Buffer_25 Buffer;
#line 372 "../openssh.h"
struct bignum_st {
   BN_ULONG *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 390 "../openssh.h"
typedef struct bignum_st BIGNUM;
#line 391 "../openssh.h"
struct rsa_st {
   int pad ;
   int32_t___0 version ;
   void const   *meth ;
   void *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   void *pss ;
   int ex_data ;
   int references ;
   int flags ;
   void *_method_mod_n ;
   void *_method_mod_p ;
   void *_method_mod_q ;
   char *bignum_data ;
   void *blinding ;
   void *mt_blinding ;
   void *lock ;
};
#line 391 "../openssh.h"
typedef struct rsa_st RSA;
#line 434 "../openssh.h"
struct dsa_st {
   int pad ;
   int32_t___0 version ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
};
#line 434 "../openssh.h"
typedef struct dsa_st DSA;
#line 1191
struct Key;
#line 1191 "../openssh.h"
typedef struct Key Key;
#line 1203 "../openssh.h"
struct KeyCert {
   Buffer certblob ;
   u_int___0 type ;
   u_int64_t serial ;
   char *key_id ;
   u_int___0 nprincipals ;
   char **principals ;
   u_int64_t valid_after ;
   u_int64_t valid_before ;
   Buffer critical ;
   Buffer extensions ;
   Key *signature_key ;
};
#line 1216 "../openssh.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
   int ecdsa_nid ;
   void *ecdsa ;
   struct KeyCert *cert ;
   u_char___0 *ed25519_sk ;
   u_char___0 *ed25519_pk ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 18 "openssh_uaf_3.c"
extern int ( /* missing proto */  error)() ;
#line 21
extern int ( /* missing proto */  buffer_init)() ;
#line 22
extern int ( /* missing proto */  key_type_plain)() ;
#line 23
extern int ( /* missing proto */  buffer_len)() ;
#line 29
extern int ( /* missing proto */  memcpy)() ;
#line 29
extern int ( /* missing proto */  buffer_ptr)() ;
#line 31
extern int ( /* missing proto */  memset)() ;
#line 32
extern int ( /* missing proto */  buffer_free)() ;
#line 11 "openssh_uaf_3.c"
static int to_blob(Key const   *key , u_char___0 **blobp , u_int___0 *lenp , int force_plain ) 
{ 
  Buffer b ;
  int len ;
  int type ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 17
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 18
    error("key_to_blob: key == NULL");
#line 19
    return (0);
  }
#line 21
  buffer_init(& b);
#line 22
  if (force_plain) {
#line 22
    tmp = key_type_plain(key->type);
#line 22
    type = tmp;
  } else {
#line 22
    type = (int )key->type;
  }
#line 23
  len = buffer_len(& b);
#line 24
  if ((unsigned long )lenp != (unsigned long )((void *)0)) {
#line 25
    *lenp = (u_int___0 )len;
  }
#line 27
  if ((unsigned long )blobp != (unsigned long )((void *)0)) {
#line 28
    tmp___0 = malloc((size_t )len);
#line 28
MemFix_dump();
    *blobp = (u_char___0 *)tmp___0;
#line 29
    tmp___1 = buffer_ptr(& b);
#line 29
    memcpy(*blobp, tmp___1, len);
  }
#line 31
  tmp___2 = buffer_ptr(& b);
#line 31
  memset(tmp___2, 0, len);
#line 32
  buffer_free(& b);
#line 33
  return (len);
}
}
#line 38 "openssh_uaf_3.c"
int key_to_blob(Key const   *key , u_char___0 **blobp , u_int___0 *lenp ) 
{ 
  int tmp ;

  {
#line 41
  tmp = to_blob(key, blobp, lenp, 0);
#line 41
  return (tmp);
}
}
#line 48
extern int ( /* missing proto */  buffer_append_space)() ;
#line 44 "openssh_uaf_3.c"
void buffer_append(Buffer *buffer , void const   *data , u_int___0 len ) 
{ 
  void *p ;
  int tmp ;

  {
#line 48
  tmp = buffer_append_space(buffer, len);
#line 48
  p = (void *)tmp;
#line 49
  memcpy(p, data, len);
#line 50
  return;
}
}
#line 58
extern int ( /* missing proto */  buffer_put_int)() ;
#line 55 "openssh_uaf_3.c"
void buffer_put_string(Buffer *buffer , void const   *buf , u_int___0 len ) 
{ 


  {
#line 58
  buffer_put_int(buffer, len);
#line 59
  buffer_append(buffer, buf, len);
#line 60
  return;
}
}
#line 73
extern int ( /* missing proto */  get_string)() ;
#line 76
extern int ( /* missing proto */  buffer_put_char)() ;
#line 81
extern int ( /* missing proto */  buffer_put_cstring)() ;
#line 84
extern int ( /* missing proto */  add_key)() ;
#line 75
extern int ( /* missing proto */  pkcs11_add_provider)() ;
#line 92
extern int ( /* missing proto */  send_msg)() ;
#line 62 "openssh_uaf_3.c"
static void process_add(void) 
{ 
  char *name ;
  char *pin ;
  Key **keys ;
  int i ;
  int nkeys ;
  u_char___0 *blob ;
  u_int___0 blen ;
  Buffer msg ;
  int tmp ;
  int tmp___0 ;

  {
#line 72
  buffer_init(& msg);
#line 73
  tmp = get_string((void *)0);
#line 73
  name = (char *)tmp;
#line 74
  tmp___0 = get_string((void *)0);
#line 74
  pin = (char *)tmp___0;
#line 75
  nkeys = pkcs11_add_provider(name, pin, & keys);
#line 75
  if (nkeys > 0) {
#line 76
    buffer_put_char(& msg, 12);
#line 77
    buffer_put_int(& msg, nkeys);
#line 78
    i = 0;
#line 78
    while (i < nkeys) {
#line 79
      key_to_blob((Key const   *)*(keys + i), & blob, & blen);
#line 80
      buffer_put_string(& msg, (void const   *)blob, blen);
#line 81
      buffer_put_cstring(& msg, name);
#line 82
      *blob = (u_char___0 )1;
#line 83
	  MemFix_dump();
	  free((void *)blob);
#line 84
      add_key(*(keys + i), name);
#line 78
      i ++;
    }
#line 86
    free((void *)keys);
  } else {
#line 88
    buffer_put_char(& msg, 5);
  }
#line 90
  free((void *)pin);
#line 91
  free((void *)name);
#line 92
  send_msg(& msg);
#line 93
  buffer_free(& msg);
#line 94
  return;
}
}
#line 97 "openssh_uaf_3.c"
int main(void) 
{ 


  {
#line 98
  process_add();
#line 99
  return (0);
}
}
