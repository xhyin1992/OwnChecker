/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 196 "../stdio.h"
typedef unsigned int u_int___0;
#line 197 "../stdio.h"
typedef unsigned long u_long___0;
#line 200 "../stdio.h"
typedef int int32_t___0;
#line 207 "../stdio.h"
typedef unsigned char u_char___0;
#line 364 "../openssh.h"
typedef u_int___0 BN_ULONG;
#line 365 "../openssh.h"
struct __anonstruct_Buffer_25 {
   u_char___0 *buf ;
   u_int___0 alloc ;
   u_int___0 offset ;
   u_int___0 end ;
};
#line 365 "../openssh.h"
typedef struct __anonstruct_Buffer_25 Buffer;
#line 372 "../openssh.h"
struct bignum_st {
   BN_ULONG *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 390 "../openssh.h"
typedef struct bignum_st BIGNUM;
#line 391 "../openssh.h"
struct rsa_st {
   int pad ;
   int32_t___0 version ;
   void const   *meth ;
   void *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   void *pss ;
   int ex_data ;
   int references ;
   int flags ;
   void *_method_mod_n ;
   void *_method_mod_p ;
   void *_method_mod_q ;
   char *bignum_data ;
   void *blinding ;
   void *mt_blinding ;
   void *lock ;
};
#line 391 "../openssh.h"
typedef struct rsa_st RSA;
#line 434 "../openssh.h"
struct dsa_st {
   int pad ;
   int32_t___0 version ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
};
#line 434 "../openssh.h"
typedef struct dsa_st DSA;
#line 1299
struct Key;
#line 1299 "../openssh.h"
typedef struct Key Key;
#line 1311 "../openssh.h"
struct KeyCert {
   Buffer certblob ;
   u_int___0 type ;
   u_int64_t serial ;
   char *key_id ;
   u_int___0 nprincipals ;
   char **principals ;
   u_int64_t valid_after ;
   u_int64_t valid_before ;
   Buffer critical ;
   Buffer extensions ;
   Key *signature_key ;
};
#line 1324 "../openssh.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
   int ecdsa_nid ;
   void *ecdsa ;
   struct KeyCert *cert ;
   u_char___0 *ed25519_sk ;
   u_char___0 *ed25519_pk ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 15 "openssh_df_2.c"
Key key  ;
#line 29
extern int ( /* missing proto */  strdup)() ;
#line 17 "openssh_df_2.c"
static int key_try_load_public(Key *k , char const   *filename , char **commentp ) 
{ 
  FILE *f ;
  u_long___0 linenum ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 23
  linenum = (u_long___0 )0;
#line 25
  f = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 26
  if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 27
    while (1) {
#line 27
      tmp___2 = rand();
#line 27
      if (tmp___2 % 2 == 1) {
#line 27
        tmp___1 = 1;
      } else {
#line 27
        tmp___1 = 0;
      }
#line 27
      if (! tmp___1) {
#line 27
        break;
      }
#line 28
      if (commentp) {
#line 29
        tmp = strdup(filename);
#line 29
        *commentp = (char *)tmp;
      }
#line 31
      fclose(f);
#line 32
      return (1);
    }
#line 34
    fclose(f);
  }
#line 36
  return (0);
}
}
#line 47 "openssh_df_2.c"
void *buffer_get_string_ret(u_int___0 *length_ptr ) 
{ 
  u_char___0 *value ;
  u_int___0 len ;
  int tmp ;
  void *tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 51
  tmp = rand();
#line 51
  len = (u_int___0 )(tmp % 1024);
#line 54
  tmp___0 = malloc((size_t )(len + 1U));
#line 54
  value = (u_char___0 *)tmp___0;
#line 56
  tmp___3 = rand();
#line 56
  if (tmp___3 % 2 == 1) {
#line 56
    tmp___2 = 1;
  } else {
#line 56
    tmp___2 = 0;
  }
#line 56
  if (tmp___2) {
#line 57
    printf((char const   * __restrict  )"buffer_get_string_ret: buffer_get failed\n");
#line 58
    free((void *)value);
#line 59
    return ((void *)0);
  }
#line 62
  *(value + len) = (u_char___0 )'\000';
#line 64
  if (length_ptr) {
#line 65
    *length_ptr = len;
  }
#line 66
  return ((void *)value);
}
}
#line 71 "openssh_df_2.c"
void *buffer_get_string(u_int___0 *length_ptr ) 
{ 
  void *ret ;

  {
#line 76
  ret = buffer_get_string_ret(length_ptr);
#line 76
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 77
    printf((char const   * __restrict  )"buffer_get_string: buffer error%s\n", "");
#line 77
    exit(1);
  }
#line 78
  return (ret);
}
}
#line 85 "openssh_df_2.c"
static Key *key_parse_public_rsa1(char **commentp ) 
{ 
  Key *pub ;
  void *tmp ;

  {
#line 90
  pub = & key;
#line 91
  if (commentp) {
#line 92
    tmp = buffer_get_string((u_int___0 *)((void *)0));
#line 92
    *commentp = (char *)tmp;
  }
#line 94
  return (pub);
}
}
#line 102 "openssh_df_2.c"
static Key *key_load_public_rsa1(char const   *filename , char **commentp ) 
{ 
  Key *pub ;

  {
#line 107
  pub = key_parse_public_rsa1(commentp);
#line 108
  if ((unsigned long )pub == (unsigned long )((void *)0)) {
#line 109
    printf((char const   * __restrict  )"Could not load \"%s\" as a RSA1 public key",
           filename);
  }
#line 110
  return (pub);
}
}
#line 115 "openssh_df_2.c"
Key *key_load_public_type(int type , char const   *filename , char **commentp ) 
{ 
  Key *pub ;

  {
#line 120
  if (type == 0) {
#line 121
    pub = key_load_public_rsa1(filename, commentp);
#line 122
    return (pub);
  }
#line 124
  return ((Key *)((void *)0));
}
}
#line 127 "openssh_df_2.c"
Key *key_load_public(char const   *filename , char **commentp ) 
{ 
  Key *pub ;
  int tmp ;
  int tmp___0 ;

  {
#line 134
  pub = key_load_public_type(0, filename, commentp);
#line 135
  if ((unsigned long )pub != (unsigned long )((void *)0)) {
#line 136
    return (pub);
  }
#line 139
  pub = & key;
#line 140
  tmp = key_try_load_public(pub, filename, commentp);
#line 140
  if (tmp == 1) {
#line 141
    return (pub);
  }
#line 144
  pub = & key;
#line 145
  tmp___0 = key_try_load_public(pub, filename, commentp);
#line 145
  if (tmp___0 == 1) {
#line 146
    return (pub);
  }
#line 147
  return ((Key *)((void *)0));
}
}
#line 150 "openssh_df_2.c"
static int delete_file(char const   *filename , int key_only ) 
{ 
  Key *public ;
  Key *cert ;
  char *certpath ;
  char *comment ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 153
  public = (Key *)((void *)0);
#line 153
  cert = (Key *)((void *)0);
#line 154
  certpath = (char *)((void *)0);
#line 154
  comment = (char *)((void *)0);
#line 155
  ret = -1;
#line 157
  public = key_load_public(filename, & comment);
#line 158
  if ((unsigned long )public == (unsigned long )((void *)0)) {
#line 159
    printf((char const   * __restrict  )"Bad key file %s\n", filename);
#line 160
    return (-1);
  }
#line 163
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Identity removed: %s (%s)\n",
          filename, comment);
#line 165
  if (key_only) {
#line 166
    goto out;
  }
#line 169
  free((void *)comment);
#line 170
  certpath = (char *)"filename";
#line 171
  cert = key_load_public((char const   *)certpath, & comment);
#line 171
  if ((unsigned long )cert == (unsigned long )((void *)0)) {
#line 172
    goto out;
  }
#line 173
  tmp___1 = rand();
#line 173
  if (tmp___1 % 2 == 1) {
#line 173
    tmp___0 = 1;
  } else {
#line 173
    tmp___0 = 0;
  }
#line 173
  if (tmp___0) {
#line 174
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Identity removed: %s (%s)\n",
            certpath, comment);
#line 176
    ret = 0;
  } else {
#line 178
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not remove identity: %s\n",
            certpath);
  }
  out: 
#line 181
  free((void *)comment);
#line 183
  return (ret);
}
}
#line 189
extern int ( /* missing proto */  time)() ;
#line 186 "openssh_df_2.c"
int main(int argc , char **argv ) 
{ 
  int key_only ;
  int tmp ;
  char *filename ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 187
  if (argc == 1) {
#line 187
    tmp = 1;
  } else {
#line 187
    tmp = 0;
  }
#line 187
  key_only = tmp;
#line 188
  if (argc == 1) {
#line 188
    tmp___0 = *(argv + 0);
  } else {
#line 188
    tmp___0 = *(argv + 1);
  }
#line 188
  filename = tmp___0;
#line 189
  tmp___1 = time((void *)0);
#line 189
  srand((unsigned int )tmp___1);
#line 190
  delete_file((char const   *)filename, key_only);
#line 191
  return (0);
}
}
