/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 372 "../openssl.h"
struct conf_st;
#line 372 "../openssl.h"
typedef struct conf_st CONF;
#line 16 "openssl_uaf_1.c"
struct lhash_node_st;
#line 16 "openssl_uaf_1.c"
typedef struct lhash_node_st OPENSSL_LH_NODE;
#line 21
struct lhash_st;
#line 21 "openssl_uaf_1.c"
typedef struct lhash_st OPENSSL_LHASH;
#line 22 "openssl_uaf_1.c"
struct lhash_node_st {
   void *data ;
   struct lhash_node_st *next ;
   unsigned long hash ;
};
#line 28 "openssl_uaf_1.c"
struct lhash_st {
   OPENSSL_LH_NODE **b ;
   int (*comp)(void const   * , void const   * ) ;
   unsigned long (*hash)(void const   * ) ;
   unsigned int num_nodes ;
   unsigned int num_alloc_nodes ;
   unsigned int p ;
   unsigned int pmax ;
   unsigned long up_load ;
   unsigned long down_load ;
   unsigned long num_items ;
   unsigned long num_expands ;
   unsigned long num_expand_reallocs ;
   unsigned long num_contracts ;
   unsigned long num_contract_reallocs ;
   unsigned long num_hash_calls ;
   unsigned long num_comp_calls ;
   unsigned long num_insert ;
   unsigned long num_replace ;
   unsigned long num_delete ;
   unsigned long num_no_delete ;
   unsigned long num_retrieve ;
   unsigned long num_retrieve_miss ;
   unsigned long num_hash_comps ;
   int error ;
};
#line 56
struct lhash_st_CONF_VALUE;
#line 56 "openssl_uaf_1.c"
struct conf_st {
   void *meth_data ;
   struct lhash_st_CONF_VALUE *data ;
};
#line 61 "openssl_uaf_1.c"
struct __anonstruct_CONF_VALUE_27 {
   char *section ;
   char *name ;
   char *value ;
};
#line 61 "openssl_uaf_1.c"
typedef struct __anonstruct_CONF_VALUE_27 CONF_VALUE;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 68 "openssl_uaf_1.c"
static char const   *save_rand_file  ;
#line 70 "openssl_uaf_1.c"
int CRYPTO_atomic_add(int *val , int amount , int *ret ) 
{ 


  {
#line 72
  *val += amount;
#line 73
  *ret = *val;
#line 75
  return (1);
}
}
#line 78 "openssl_uaf_1.c"
static OPENSSL_LH_NODE **getrn(OPENSSL_LHASH *lh , void const   *data , unsigned long *rhash ) 
{ 
  OPENSSL_LH_NODE **ret ;
  OPENSSL_LH_NODE *n1 ;
  unsigned long hash ;
  unsigned long nn ;
  int (*cf)(void const   * , void const   * ) ;
  int scratch ;
  int tmp ;

  {
#line 86
  hash = (*(lh->hash))(data);
#line 87
  CRYPTO_atomic_add((int *)(& lh->num_hash_calls), 1, & scratch);
#line 88
  *rhash = hash;
#line 90
  nn = hash % (unsigned long )lh->pmax;
#line 91
  if (nn < (unsigned long )lh->p) {
#line 92
    nn = hash % (unsigned long )lh->num_alloc_nodes;
  }
#line 94
  cf = lh->comp;
#line 95
  ret = lh->b + (int )nn;
#line 96
  n1 = *ret;
#line 96
  while ((unsigned long )n1 != (unsigned long )((void *)0)) {
#line 97
    CRYPTO_atomic_add((int *)(& lh->num_hash_comps), 1, & scratch);
#line 98
    if (n1->hash != hash) {
#line 99
      ret = & n1->next;
#line 100
      goto __Cont;
    }
#line 102
    CRYPTO_atomic_add((int *)(& lh->num_comp_calls), 1, & scratch);
#line 103
    tmp = (*cf)((void const   *)n1->data, data);
#line 103
    if (tmp == 0) {
#line 104
      break;
    }
#line 105
    ret = & n1->next;
    __Cont: /* CIL Label */ 
#line 96
    n1 = n1->next;
  }
#line 107
  return (ret);
}
}
#line 111 "openssl_uaf_1.c"
void lh_CONF_VALUE_free(OPENSSL_LHASH *lh ) 
{ 
  unsigned int i ;
  OPENSSL_LH_NODE *n ;
  OPENSSL_LH_NODE *nn ;

  {
#line 116
  if ((unsigned long )lh == (unsigned long )((void *)0)) {
#line 117
    return;
  }
#line 119
  i = 0U;
#line 119
  while (i < lh->num_nodes) {
#line 120
    n = *(lh->b + i);
#line 121
    while ((unsigned long )n != (unsigned long )((void *)0)) {
#line 122
      nn = n->next;
#line 123
      free((void *)n);
#line 124
      n = nn;
    }
#line 119
    i ++;
  }
#line 127
  free((void *)lh->b);
#line 128
  free((void *)lh);
#line 129
  return;
}
}
#line 131 "openssl_uaf_1.c"
CONF_VALUE *lh_CONF_VALUE_new(void) 
{ 
  OPENSSL_LHASH *ret ;
  void *tmp ;
  OPENSSL_LH_NODE **tmp___0 ;
  void *tmp___1 ;

  {
#line 135
  tmp = malloc(sizeof(*ret));
#line 135
  ret = (OPENSSL_LHASH *)tmp;
#line 135
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 136
    return ((CONF_VALUE *)((void *)0));
  }
#line 137
  tmp___1 = malloc(sizeof(*(ret->b)));
#line 137
  tmp___0 = (OPENSSL_LH_NODE **)tmp___1;
#line 137
  ret->b = tmp___0;
#line 137
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 138
    goto err;
  }
#line 139
  return ((CONF_VALUE *)ret);
  err: 
#line 142
  free((void *)ret->b);
#line 143
  free((void *)ret);
#line 144
  return ((CONF_VALUE *)((void *)0));
}
}
#line 147 "openssl_uaf_1.c"
void *lh_CONF_VALUE_retrieve(OPENSSL_LHASH *lh , void const   *data ) 
{ 
  unsigned long hash ;
  OPENSSL_LH_NODE **rn ;
  void *ret ;
  int scratch ;

  {
#line 154
  lh->error = 0;
#line 155
  rn = getrn(lh, data, & hash);
#line 157
  if ((unsigned long )*rn == (unsigned long )((void *)0)) {
#line 158
    CRYPTO_atomic_add((int *)(& lh->num_retrieve_miss), 1, & scratch);
#line 159
    return ((void *)0);
  } else {
#line 161
    ret = (*rn)->data;
#line 162
    CRYPTO_atomic_add((int *)(& lh->num_retrieve), 1, & scratch);
  }
#line 164
  return (ret);
}
}
#line 167 "openssl_uaf_1.c"
char *_CONF_get_string(CONF const   *conf , char const   *section , char const   *name ) 
{ 
  CONF_VALUE *v ;
  CONF_VALUE vv ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 173
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 174
    return ((char *)((void *)0));
  }
#line 175
  if ((unsigned long )conf != (unsigned long )((void *)0)) {
#line 176
    if ((unsigned long )section != (unsigned long )((void *)0)) {
#line 177
      vv.name = (char *)name;
#line 178
      vv.section = (char *)section;
#line 179
      tmp = lh_CONF_VALUE_retrieve((OPENSSL_LHASH *)conf->data, (void const   *)(& vv));
#line 179
      v = (CONF_VALUE *)tmp;
#line 180
      if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 181
        return (v->value);
      }
#line 182
      return ((char *)((void *)0));
    }
#line 184
    vv.section = (char *)"default";
#line 185
    vv.name = (char *)name;
#line 186
    tmp___0 = lh_CONF_VALUE_retrieve((OPENSSL_LHASH *)conf->data, (void const   *)(& vv));
#line 186
    v = (CONF_VALUE *)tmp___0;
#line 187
    if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 188
      return (v->value);
    } else {
#line 190
      return ((char *)((void *)0));
    }
  } else {
#line 192
    tmp___1 = getenv(name);
#line 192
    return (tmp___1);
  }
}
}
#line 195 "openssl_uaf_1.c"
char *NCONF_get_string(CONF const   *conf , char const   *group , char const   *name ) 
{ 
  char *s ;
  char *tmp ;

  {
#line 197
  tmp = _CONF_get_string(conf, group, name);
#line 197
  s = tmp;
#line 199
  if (s) {
#line 200
    return (s);
  }
#line 202
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 203
    return ((char *)((void *)0));
  }
#line 205
  return ((char *)((void *)0));
}
}
#line 208 "openssl_uaf_1.c"
void app_RAND_load_conf(CONF *c , char const   *section ) 
{ 
  char const   *randfile ;
  char *tmp ;

  {
#line 210
  tmp = NCONF_get_string((CONF const   *)c, section, "RANDFILE");
#line 210
  randfile = (char const   *)tmp;
#line 212
  if ((unsigned long )randfile == (unsigned long )((void *)0)) {
#line 213
    return;
  }
#line 216
  if ((unsigned long )save_rand_file == (unsigned long )((void *)0)) {
#line 217
    save_rand_file = randfile;
  }
#line 218
  return;
}
}
#line 224
extern int ( /* missing proto */  RAND_write_file)() ;
#line 220 "openssl_uaf_1.c"
void app_RAND_write(void) 
{ 
  int tmp ;

  {
#line 222
  if ((unsigned long )save_rand_file == (unsigned long )((void *)0)) {
#line 223
    return;
  }
#line 224
  tmp = RAND_write_file(save_rand_file);
#line 224
  if (tmp == -1) {
#line 225
    printf((char const   * __restrict  )"RAND_write_file error\n");
  }
#line 227
  return;
}
}
#line 229 "openssl_uaf_1.c"
int _CONF_new_data(CONF *conf ) 
{ 
  CONF_VALUE *tmp ;

  {
#line 231
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 232
    return (0);
  }
#line 234
  if ((unsigned long )conf->data == (unsigned long )((void *)0)) {
#line 235
    tmp = lh_CONF_VALUE_new();
#line 235
    conf->data = (struct lhash_st_CONF_VALUE *)tmp;
#line 236
    if ((unsigned long )conf->data == (unsigned long )((void *)0)) {
#line 237
      return (0);
    }
  }
#line 239
  return (1);
}
}
#line 242 "openssl_uaf_1.c"
void CONF_free(CONF *conf ) 
{ 


  {
#line 244
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 245
    return;
  } else
#line 244
  if ((unsigned long )conf->data == (unsigned long )((void *)0)) {
#line 245
    return;
  }
#line 247
  lh_CONF_VALUE_free((OPENSSL_LHASH *)conf->data);
#line 248
  free((void *)conf);
#line 249
  return;
}
}
#line 251 "openssl_uaf_1.c"
CONF *CONF_new(void) 
{ 
  CONF *ret ;
  void *tmp ;

  {
#line 255
  tmp = malloc(sizeof(*ret));
#line 255
  ret = (CONF *)tmp;
#line 256
  return (ret);
}
}
#line 259 "openssl_uaf_1.c"
void foo(void) 
{ 
  CONF *conf ;
  int tmp ;

  {
#line 261
  conf = (CONF *)((void *)0);
#line 262
  conf = CONF_new();
#line 262
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 263
    goto end;
  }
#line 264
  conf->data = (struct lhash_st_CONF_VALUE *)((void *)0);
#line 265
  tmp = _CONF_new_data(conf);
#line 265
  if (tmp == 0) {
#line 266
    goto end;
  }
#line 267
  app_RAND_load_conf(conf, "section");
  end: 
#line 270
  CONF_free(conf);
#line 271
  return;
}
}
#line 273 "openssl_uaf_1.c"
int main(void) 
{ 


  {
#line 275
  foo();
#line 276
  app_RAND_write();
#line 277
  return (0);
}
}
