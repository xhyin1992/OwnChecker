/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 380 "../openssl.h"
struct ssl_st;
#line 380 "../openssl.h"
typedef struct ssl_st SSL;
#line 22 "openssl_uaf_2.c"
struct async_wait_ctx_st;
#line 22 "openssl_uaf_2.c"
typedef struct async_wait_ctx_st ASYNC_WAIT_CTX;
#line 34 "openssl_uaf_2.c"
struct ssl_st {
   ASYNC_WAIT_CTX *waitctx ;
};
#line 47 "openssl_uaf_2.c"
struct fd_lookup_st {
   void const   *key ;
   int fd ;
   void *custom_data ;
   void (*cleanup)(ASYNC_WAIT_CTX * , void const   * , int  , void * ) ;
   int add ;
   int del ;
   struct fd_lookup_st *next ;
};
#line 57 "openssl_uaf_2.c"
struct async_wait_ctx_st {
   struct fd_lookup_st *fds ;
   size_t numadd ;
   size_t numdel ;
};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 69 "openssl_uaf_2.c"
int ASYNC_WAIT_CTX_get_all_fds(ASYNC_WAIT_CTX *ctx , int *fd , size_t *numfds ) 
{ 
  struct fd_lookup_st *curr ;

  {
#line 74
  curr = ctx->fds;
#line 75
  *numfds = (size_t )0;
#line 76
  while ((unsigned long )curr != (unsigned long )((void *)0)) {
#line 77
    if (curr->del) {
#line 79
      curr = curr->next;
#line 80
      continue;
    }
#line 82
    if ((unsigned long )fd != (unsigned long )((void *)0)) {
#line 83
      *fd = curr->fd;
#line 84
      fd ++;
    }
#line 86
    (*numfds) ++;
#line 87
    curr = curr->next;
  }
#line 89
  return (1);
}
}
#line 92 "openssl_uaf_2.c"
int SSL_get_all_async_fds(SSL *s , int *fds , size_t *numfds ) 
{ 
  ASYNC_WAIT_CTX *ctx ;
  int tmp ;

  {
#line 94
  ctx = s->waitctx;
#line 96
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 97
    return (0);
  }
#line 98
  tmp = ASYNC_WAIT_CTX_get_all_fds(ctx, fds, numfds);
#line 98
  return (tmp);
}
}
#line 101 "openssl_uaf_2.c"
void wait_for_async(SSL *s ) 
{ 
  int width ;
  fd_set asyncfds ;
  int *fds ;
  size_t numfds ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 104
  width = 0;
#line 109
  tmp = SSL_get_all_async_fds(s, (int *)((void *)0), & numfds);
#line 109
  if (! tmp) {
#line 110
    return;
  }
#line 111
  if (numfds == 0UL) {
#line 112
    return;
  }
#line 113
  tmp___0 = malloc(sizeof(int ) * numfds);
#line 113
  fds = (int *)tmp___0;
  MemFix_dump();
#line 114
  tmp___1 = SSL_get_all_async_fds(s, fds, & numfds);
#line 114
  if (! tmp___1) {
#line 115
    free((void *)fds);
  }
#line 118
  while (numfds > 0UL) {
#line 119
    if (width <= *fds) {
#line 120
      width = *fds + 1;
    }
#line 121
    asyncfds.__fds_bits[*fds / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << *fds % (8 * (int )sizeof(__fd_mask )));
#line 122
    numfds --;
#line 123
    fds ++;
  }
  MemFix_dump();
#line 125
  select(width, (fd_set * __restrict  )((void *)(& asyncfds)), (fd_set * __restrict  )((void *)0),
         (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
#line 126
  return;
}
}
#line 128 "openssl_uaf_2.c"
int main(void) 
{ 
  SSL s ;

  {
#line 131
  wait_for_async(& s);
#line 132
  return (0);
}
}
