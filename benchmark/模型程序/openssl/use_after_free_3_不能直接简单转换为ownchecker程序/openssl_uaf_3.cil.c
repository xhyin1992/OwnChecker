/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 380 "../openssl.h"
struct ssl_st;
#line 380 "../openssl.h"
typedef struct ssl_st SSL;
#line 381
struct ssl_ctx_st;
#line 381 "../openssl.h"
typedef struct ssl_ctx_st SSL_CTX;
#line 17 "openssl_uaf_3.c"
struct ssl3_buffer_st {
   unsigned char *buf ;
   size_t len ;
   int offset ;
   int left ;
};
#line 17 "openssl_uaf_3.c"
typedef struct ssl3_buffer_st SSL3_BUFFER;
#line 25 "openssl_uaf_3.c"
struct ssl3_state_st {
   SSL3_BUFFER rbuf ;
};
#line 29 "openssl_uaf_3.c"
struct ssl3_buf_freelist_entry_st {
   struct ssl3_buf_freelist_entry_st *next ;
};
#line 29 "openssl_uaf_3.c"
typedef struct ssl3_buf_freelist_entry_st SSL3_BUF_FREELIST_ENTRY;
#line 33 "openssl_uaf_3.c"
struct ssl3_buf_freelist_st {
   size_t chunklen ;
   unsigned int len ;
   struct ssl3_buf_freelist_entry_st *head ;
};
#line 33 "openssl_uaf_3.c"
typedef struct ssl3_buf_freelist_st SSL3_BUF_FREELIST;
#line 39 "openssl_uaf_3.c"
struct ssl_ctx_st {
   struct ssl3_buf_freelist_st *rbuf_freelist ;
   struct ssl3_buf_freelist_st *wbuf_freelist ;
};
#line 44 "openssl_uaf_3.c"
struct ssl_st {
   struct ssl3_state_st *s3 ;
   unsigned char *packet ;
   int rstate ;
   int rwstate ;
   int shutdown ;
   unsigned long mode ;
   SSL_CTX *ctx ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 54 "openssl_uaf_3.c"
static void *freelist_extract(SSL_CTX *ctx , int for_read , int sz ) 
{ 
  SSL3_BUF_FREELIST *list ;
  SSL3_BUF_FREELIST_ENTRY *ent ;
  void *result ;

  {
#line 58
  ent = (SSL3_BUF_FREELIST_ENTRY *)((void *)0);
#line 59
  result = (void *)0;
#line 61
  if (for_read) {
#line 61
    list = ctx->rbuf_freelist;
  } else {
#line 61
    list = ctx->wbuf_freelist;
  }
#line 62
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 62
    if (sz == (int )list->chunklen) {
#line 63
      ent = list->head;
    }
  }
#line 64
  if ((unsigned long )ent != (unsigned long )((void *)0)) {
#line 66
    list->head = ent->next;
#line 67
    result = (void *)ent;
#line 68
    (list->len) --;
#line 68
    if (list->len == 0U) {
#line 69
      list->chunklen = (size_t )0;
    }
  }
#line 71
  if (! result) {
#line 72
    result = malloc((size_t )sz);
  }
#line 73
  return (result);
}
}
#line 76 "openssl_uaf_3.c"
static void freelist_insert(SSL_CTX *ctx , int for_read , size_t sz , void *mem ) 
{ 
  SSL3_BUF_FREELIST *list ;
  SSL3_BUF_FREELIST_ENTRY *ent ;

  {
#line 82
  if (for_read) {
#line 82
    list = ctx->rbuf_freelist;
  } else {
#line 82
    list = ctx->wbuf_freelist;
  }
#line 83
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 83
    if (sz == list->chunklen) {
#line 83
      goto _L;
    } else
#line 83
    if (list->chunklen == 0UL) {
      _L: /* CIL Label */ 
#line 83
      if (sz >= sizeof(*ent)) {
#line 87
        list->chunklen = sz;
#line 88
        ent = (SSL3_BUF_FREELIST_ENTRY *)mem;
#line 89
        ent->next = list->head;
#line 90
        list->head = ent;
#line 91
        (list->len) ++;
#line 92
        mem = (void *)0;
      }
    }
  }
#line 95
  if (mem) {
#line 96
    free(mem);
  }
#line 97
  return;
}
}
#line 99 "openssl_uaf_3.c"
int ssl3_release_read_buffer(SSL *s ) 
{ 


  {
#line 101
  if ((unsigned long )(s->s3)->rbuf.buf != (unsigned long )((void *)0)) {
#line 103
    freelist_insert(s->ctx, 1, (s->s3)->rbuf.len, (void *)(s->s3)->rbuf.buf);
#line 104
    (s->s3)->rbuf.buf = (unsigned char *)((void *)0);
  }
#line 106
  return (1);
}
}
#line 113 "openssl_uaf_3.c"
int ssl3_setup_read_buffer(SSL *s ) 
{ 
  unsigned char *p ;
  size_t len ;
  size_t align ;
  size_t headerlen ;
  void *tmp ;

  {
#line 116
  align = (size_t )0;
#line 118
  if ((unsigned long )(s->s3)->rbuf.buf == (unsigned long )((void *)0)) {
#line 120
    len = (16704UL + headerlen) + align;
#line 123
    tmp = freelist_extract(s->ctx, 1, (int )len);
#line 123
    p = (unsigned char *)tmp;
#line 123
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 124
      goto err;
    }
#line 125
    (s->s3)->rbuf.buf = p;
#line 126
    (s->s3)->rbuf.len = len;
  }
#line 129
  s->packet = (s->s3)->rbuf.buf + 0;
#line 130
  return (1);
  err: 
#line 133
  return (0);
}
}
#line 137 "openssl_uaf_3.c"
int ssl3_read_bytes(SSL *s , int type , unsigned char *buf , int len , int peek ) 
{ 
  unsigned int n ;
  int tmp ;

  {
#line 142
  if ((unsigned long )(s->s3)->rbuf.buf == (unsigned long )((void *)0)) {
#line 143
    tmp = ssl3_setup_read_buffer(s);
#line 143
    if (! tmp) {
#line 144
      return (-1);
    }
  }
#line 148
  if (s->shutdown & 2) {
#line 150
    s->rwstate = 1;
#line 151
    return (0);
  }
#line 154
  if (len <= 0) {
#line 154
    return (len);
  }
#line 156
  n = (unsigned int )len;
#line 158
  if (! peek) {
#line 160
    s->rstate = 240;
#line 161
    if (s->mode & 16UL) {
#line 162
      ssl3_release_read_buffer(s);
    }
  }
#line 164
  return ((int )n);
}
}
#line 167 "openssl_uaf_3.c"
int main(void) 
{ 
  SSL *s ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 169
  tmp = malloc(sizeof(*s));
#line 169
  s = (SSL *)tmp;
#line 170
  tmp___0 = malloc(sizeof(*(s->s3)));
#line 170
  s->s3 = (struct ssl3_state_st *)tmp___0;
#line 171
  ssl3_read_bytes(s, 0, (unsigned char *)"buf", 1, 0);
#line 172
  if ((s->s3)->rbuf.left != 0) {
#line 173
    printf((char const   * __restrict  )"%d\n", s->packet);
  }
#line 174
  free((void *)(s->s3)->rbuf.buf);
#line 175
  free((void *)s->s3);
#line 176
  free((void *)s);
#line 177
  return (0);
}
}
