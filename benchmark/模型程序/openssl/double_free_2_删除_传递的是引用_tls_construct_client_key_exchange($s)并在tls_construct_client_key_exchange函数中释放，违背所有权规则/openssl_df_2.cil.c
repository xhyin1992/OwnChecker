/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 378 "../openssl.h"
struct ssl_st;
#line 378 "../openssl.h"
typedef struct ssl_st SSL;
#line 21 "openssl_df_2.c"
typedef void WPACKET;
#line 23
struct ssl3_state_st;
#line 23 "openssl_df_2.c"
struct ssl_st {
   struct ssl3_state_st *s3 ;
   int client_version ;
};
#line 28 "openssl_df_2.c"
struct __anonstruct_tmp_27 {
   unsigned char *pms ;
   size_t pmslen ;
};
#line 28 "openssl_df_2.c"
struct ssl3_state_st {
   struct __anonstruct_tmp_27 tmp ;
};
#line 28 "openssl_df_2.c"
typedef struct ssl3_state_st SSL3_STATE;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 36 "openssl_df_2.c"
int ssl3_new(SSL *s ) 
{ 
  SSL3_STATE *s3 ;
  void *tmp ;

  {
#line 40
  tmp = malloc(sizeof(*s3));
#line 40
  s3 = (SSL3_STATE *)tmp;
#line 40
  if ((unsigned long )s3 == (unsigned long )((void *)0)) {
#line 41
    goto err;
  }
#line 42
  s->s3 = s3;
#line 43
  return (1);
  err: 
#line 45
  return (0);
}
}
#line 48 "openssl_df_2.c"
void ssl3_free(SSL *s ) 
{ 


  {
#line 50
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 51
    return;
  } else
#line 50
  if ((unsigned long )s->s3 == (unsigned long )((void *)0)) {
#line 51
    return;
  }
#line 53
  free((void *)(s->s3)->tmp.pms);
#line 55
  free((void *)s->s3);
#line 56
  s->s3 = (struct ssl3_state_st *)((void *)0);
#line 57
  return;
}
}
#line 75
extern int ( /* missing proto */  RAND_bytes)() ;
#line 83
extern int ( /* missing proto */  ssl_log_rsa_client_key_exchange)() ;
#line 59 "openssl_df_2.c"
static int tls_construct_cke_rsa(SSL *s , WPACKET *pkt , int *al ) 
{ 
  unsigned char *encdata ;
  size_t enclen ;
  unsigned char *pms ;
  size_t pmslen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 61
  encdata = (unsigned char *)((void *)0);
#line 63
  pms = (unsigned char *)((void *)0);
#line 64
  pmslen = (size_t )0;
#line 66
  pmslen = (size_t )48;
#line 67
  tmp = malloc(pmslen);
#line 67
  pms = (unsigned char *)tmp;
#line 68
  if ((unsigned long )pms == (unsigned long )((void *)0)) {
#line 69
    return (0);
  }
#line 72
  *(pms + 0) = (unsigned char )(s->client_version >> 8);
#line 73
  *(pms + 1) = (unsigned char )(s->client_version & 255);
#line 75
  tmp___0 = RAND_bytes(pms + 2, (int )(pmslen - 2UL));
#line 75
  if (tmp___0 <= 0) {
#line 76
    goto err;
  }
#line 79
  (s->s3)->tmp.pms = pms;
#line 80
  (s->s3)->tmp.pmslen = pmslen;
#line 83
  tmp___1 = ssl_log_rsa_client_key_exchange(s, encdata, enclen, pms, pmslen);
#line 83
  if (! tmp___1) {
#line 84
    goto err;
  }
#line 86
  return (1);
  err: 
#line 88
  free((void *)(s->s3)->tmp.pms);
#line 90
  return (0);
}
}
#line 93 "openssl_df_2.c"
int tls_construct_client_key_exchange(SSL *s , WPACKET *pkt ) 
{ 
  int al ;
  int tmp ;

  {
#line 96
  al = -1;
#line 98
  tmp = tls_construct_cke_rsa(s, pkt, & al);
#line 98
  if (! tmp) {
#line 99
    goto err;
  }
#line 101
  return (1);
  err: 
#line 103
  free((void *)(s->s3)->tmp.pms);
#line 104
  (s->s3)->tmp.pms = (unsigned char *)((void *)0);
#line 105
  return (0);
}
}
#line 108 "openssl_df_2.c"
int main(void) 
{ 
  SSL s ;
  int tmp ;
  int tmp___0 ;

  {
#line 111
  tmp = ssl3_new(& s);
#line 111
  if (! tmp) {
#line 112
    return (1);
  }
#line 114
  tmp___0 = tls_construct_client_key_exchange(& s, (void *)0);
#line 114
  if (! tmp___0) {
#line 115
    goto end;
  }
#line 116
  printf((char const   * __restrict  )"%d\n", (s.s3)->tmp.pms);
  end: 
#line 118
  ssl3_free(& s);
#line 119
  return (0);
}
}
