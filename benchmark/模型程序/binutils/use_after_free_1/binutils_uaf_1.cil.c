/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 30 "../include/common.h"
typedef int bool;
#line 35 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 37 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 9 "binutils_uaf_1.c"
struct riscv_subset {
   char const   *name ;
   struct riscv_subset *next ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 32 "../include/common.h"
bool true  =    1;
#line 33 "../include/common.h"
bool false  =    0;
#line 45 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 50 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 51 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 53
void discard_cleanups(struct cleanup *old_chain ) ;
#line 54
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 56
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 57
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 59
void do_cleanups(struct cleanup *old_chain ) ;
#line 60
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 63
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 66
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 69 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 72
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 73
  return;
}
}
#line 75 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 78
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 79
  return;
}
}
#line 81 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 87
  while (1) {
#line 87
    ptr = *pmy_chain;
#line 87
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 87
      break;
    }
#line 89
    *pmy_chain = ptr->next;
#line 90
    if (ptr->free_arg) {
#line 91
      (*(ptr->free_arg))(ptr->arg);
    }
#line 92
    free((void *)ptr);
  }
#line 95
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 96
  return;
}
}
#line 98 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 104
  while (1) {
#line 104
    ptr = *pmy_chain;
#line 104
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 104
      break;
    }
#line 106
    *pmy_chain = ptr->next;
#line 107
    (*(ptr->function))(ptr->arg);
#line 108
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 109
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 110
    if (ptr->free_arg) {
#line 111
      (*(ptr->free_arg))(ptr->arg);
    }
#line 113
    free((void *)ptr);
  }
#line 115
  return;
}
}
#line 117 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 119
  do_my_cleanups(& cleanup_chain, old_chain);
#line 120
  return;
}
}
#line 122 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 126
  tmp = malloc(sizeof(struct cleanup ));
#line 126
  new = (struct cleanup *)tmp;
#line 128
  old_chain = *pmy_chain;
#line 130
  new->next = *pmy_chain;
#line 131
  new->function = function;
#line 132
  new->free_arg = free_arg;
#line 133
  new->arg = arg;
#line 134
  *pmy_chain = new;
#line 136
  if ((unsigned long )old_chain == (unsigned long )((struct cleanup *)0)) {
#line 137
    exit(1);
  }
#line 139
  return (old_chain);
}
}
#line 142 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 146
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))0);
#line 146
  return (tmp);
}
}
#line 149 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 152
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 152
  return (tmp);
}
}
#line 16 "binutils_uaf_1.c"
static struct riscv_subset *riscv_subsets  ;
#line 18 "binutils_uaf_1.c"
static unsigned int xlen  =    0U;
#line 48
extern int ( /* missing proto */  strdup)() ;
#line 43 "binutils_uaf_1.c"
static void riscv_add_subset(char const   *subset ) 
{ 
  char c ;
  struct riscv_subset *s ;
  void *tmp ;
  int tmp___0 ;

  {
#line 46
  c = (char )*subset;
#line 47
  tmp = malloc(sizeof(*s));
#line 47
  s = (struct riscv_subset *)tmp;
#line 48
  tmp___0 = strdup(subset);
#line 48
  s->name = (char const   *)tmp___0;
#line 49
  s->next = riscv_subsets;
#line 50
  riscv_subsets = s;
#line 51
  return;
}
}
#line 65
extern int ( /* missing proto */  strncmp)() ;
#line 107
extern int ( /* missing proto */  strlen)() ;
#line 112
extern int ( /* missing proto */  strchr)() ;
#line 53 "binutils_uaf_1.c"
static void riscv_set_arch(char const   *s ) 
{ 
  char const   *all_subsets ;
  char const   *extension ;
  char const   *p ;
  int tmp ;
  int tmp___0 ;
  char subset[2] ;
  char *subset___0 ;
  int tmp___1 ;
  char *q ;
  int tmp___2 ;
  char subset___1[2] ;
  char subset___2[2] ;
  int tmp___3 ;

  {
#line 56
  all_subsets = "imafdc";
#line 57
  extension = (char const   *)0;
#line 58
  p = s;
#line 60
  tmp___0 = strncmp(p, "rv32", 4);
#line 60
  if (tmp___0 == 0) {
#line 62
    xlen = 32U;
#line 63
    p += 4;
  } else {
#line 65
    tmp = strncmp(p, "rv64", 4);
#line 65
    if (tmp == 0) {
#line 67
      xlen = 64U;
#line 68
      p += 4;
    } else {
#line 71
      printf((char const   * __restrict  )"-march=%s: ISA string must begin with rv32 or rv64",
             s);
#line 71
      exit(1);
    }
  }
#line 73
  switch ((int const   )*p) {
  case 105: 
#line 76
  break;
  case 103: 
#line 79
  p ++;
#line 80
  while ((int const   )*all_subsets != 99) {
#line 82
    subset[0] = (char )*all_subsets;
#line 82
    subset[1] = (char )'\000';
#line 83
    riscv_add_subset((char const   *)(subset));
#line 80
    all_subsets ++;
  }
#line 85
  break;
  default: 
#line 88
  printf((char const   * __restrict  )"-march=%s: first ISA subset must be `i\' or `g\'",
         s);
#line 88
  exit(1);
  }
#line 91
  while (*p) {
#line 93
    if ((int const   )*p == 120) {
#line 95
      tmp___1 = strdup(p);
#line 95
      subset___0 = (char *)tmp___1;
#line 95
      q = subset___0;
#line 97
      while (1) {
#line 97
        q ++;
#line 97
        if ((int )*q != 0) {
#line 97
          if (! ((int )*q != 95)) {
#line 97
            break;
          }
        } else {
#line 97
          break;
        }
      }
#line 99
      *q = (char )'\000';
#line 101
      if (extension) {
#line 102
        printf((char const   * __restrict  )"-march=%s: only one non-standard extension is supported",
               extension);
#line 102
        exit(1);
      }
#line 105
      extension = (char const   *)subset___0;
#line 106
      riscv_add_subset((char const   *)subset___0);
#line 107
      tmp___2 = strlen(subset___0);
#line 107
      p += tmp___2;
#line 108
      free((void *)subset___0);
    } else
#line 110
    if ((int const   )*p == 95) {
#line 111
      p ++;
    } else {
#line 112
      tmp___3 = strchr(all_subsets, (int const   )*p);
#line 112
      all_subsets = (char const   *)tmp___3;
#line 112
      if ((unsigned long )all_subsets != (unsigned long )((char const   *)0)) {
#line 114
        subset___1[0] = (char )*p;
#line 114
        subset___1[1] = (char)0;
#line 115
        riscv_add_subset((char const   *)(subset___1));
#line 116
        all_subsets ++;
#line 117
        p ++;
      } else
#line 119
      if ((int const   )*p == 113) {
#line 121
        subset___2[0] = (char )*p;
#line 121
        subset___2[1] = (char)0;
#line 122
        riscv_add_subset((char const   *)(subset___2));
#line 123
        p ++;
      } else {
#line 126
        printf((char const   * __restrict  )"-march=%s: unsupported ISA subset `%c\'",
               (int const   )*p);
#line 126
        exit(1);
      }
    }
  }
#line 128
  return;
}
}
#line 130 "binutils_uaf_1.c"
int getopt(char *optargv ) 
{ 


  {
#line 132
  if ((int )*optargv == 48) {
#line 133
    return (0);
  }
#line 134
  return (1);
}
}
#line 139
extern int ( /* missing proto */  time)() ;
#line 137 "binutils_uaf_1.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;
  char *string ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 139
  tmp = time(0);
#line 139
  srand((unsigned int )tmp);
#line 141
  while (1) {
#line 141
    tmp___2 = rand();
#line 141
    if (tmp___2 % 2 == 1) {
#line 141
      tmp___1 = 1;
    } else {
#line 141
      tmp___1 = 0;
    }
#line 141
    if (! tmp___1) {
#line 141
      break;
    }
#line 142
    string = (char *)"rv32ix_x";
#line 143
    riscv_set_arch((char const   *)string);
  }
#line 145
  return (0);
}
}
