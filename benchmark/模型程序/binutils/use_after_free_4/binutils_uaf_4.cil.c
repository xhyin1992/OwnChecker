/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 12 "binutils_uaf_4.c"
typedef int CORE_ADDR;
#line 14 "binutils_uaf_4.c"
struct svr4_info {
   CORE_ADDR main_lm_addr ;
};
#line 20 "binutils_uaf_4.c"
struct lm_info {
   CORE_ADDR l_addr ;
   CORE_ADDR l_addr_inferior ;
   unsigned int l_addr_p : 1 ;
   CORE_ADDR lm_addr ;
   CORE_ADDR l_ld ;
   CORE_ADDR l_next ;
   CORE_ADDR l_prev ;
   CORE_ADDR l_name ;
};
#line 28 "binutils_uaf_4.c"
struct so_list {
   struct so_list *next ;
   struct lm_info *lm_info ;
   char so_original_name[512] ;
   char so_name[512] ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 36 "binutils_uaf_4.c"
void free_so(struct so_list *so ) 
{ 


  {
#line 39
  free((void *)so);
#line 40
  return;
}
}
#line 42 "binutils_uaf_4.c"
static void do_free_so(void *arg ) 
{ 
  struct so_list *so ;

  {
#line 45
  so = (struct so_list *)arg;
#line 47
  free_so(so);
#line 48
  return;
}
}
#line 50 "binutils_uaf_4.c"
struct cleanup *make_cleanup_free_so(struct so_list *so ) 
{ 
  struct cleanup *tmp ;

  {
#line 53
  tmp = make_cleanup(& do_free_so, (void *)so);
#line 53
  return (tmp);
}
}
#line 73
extern int ( /* missing proto */  lm_info_read)() ;
#line 84
extern int ( /* missing proto */  warning)() ;
#line 84
extern int ( /* missing proto */  paddress)() ;
#line 84
extern int ( /* missing proto */  target_gdbarch)() ;
#line 84
extern int ( /* missing proto */  _)() ;
#line 98
extern int ( /* missing proto */  get_svr4_info)() ;
#line 107
extern int ( /* missing proto */  target_read_string)() ;
#line 117
extern int ( /* missing proto */  safe_strerror)() ;
#line 123
extern int ( /* missing proto */  strncpy)() ;
#line 125
extern int ( /* missing proto */  strcpy)() ;
#line 130
extern int ( /* missing proto */  match_main)() ;
#line 56 "binutils_uaf_4.c"
static int svr4_read_so_list(CORE_ADDR lm , CORE_ADDR prev_lm , struct so_list ***link_ptr_ptr ,
                             int ignore_first ) 
{ 
  struct so_list *first ;
  CORE_ADDR next_lm ;
  struct so_list *new ;
  struct cleanup *old_chain ;
  int errcode ;
  char *buffer ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct svr4_info *info ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 60
  first = (struct so_list *)((void *)0);
#line 63
  while (lm != 0) {
#line 70
    tmp = calloc((size_t )1, sizeof(struct so_list ));
#line 70
    new = (struct so_list *)tmp;
#line 71
    old_chain = make_cleanup_free_so(new);
#line 73
    tmp___0 = lm_info_read(lm);
#line 73
    new->lm_info = (struct lm_info *)tmp___0;
#line 74
    if ((unsigned long )new->lm_info == (unsigned long )((void *)0)) {
#line 76
      do_cleanups(old_chain);
#line 77
      return (0);
    }
#line 80
    next_lm = (new->lm_info)->l_next;
#line 82
    if ((new->lm_info)->l_prev != prev_lm) {
#line 84
      tmp___1 = target_gdbarch();
#line 84
      tmp___2 = paddress(tmp___1, (new->lm_info)->l_prev);
#line 84
      tmp___3 = target_gdbarch();
#line 84
      tmp___4 = paddress(tmp___3, prev_lm);
#line 84
      tmp___5 = _("Corrupted shared library list: %s != %s");
#line 84
      warning(tmp___5, tmp___4, tmp___2);
#line 87
      do_cleanups(old_chain);
#line 88
      return (0);
    }
#line 96
    if (ignore_first) {
#line 96
      if ((new->lm_info)->l_prev == 0) {
#line 98
        tmp___6 = get_svr4_info();
#line 98
        info = (struct svr4_info *)tmp___6;
#line 100
        first = new;
#line 101
        info->main_lm_addr = (new->lm_info)->lm_addr;
#line 102
        do_cleanups(old_chain);
#line 103
        goto __Cont;
      }
    }
#line 107
    target_read_string((new->lm_info)->l_name, & buffer, 511, & errcode);
#line 109
    if (errcode != 0) {
#line 115
      if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 117
        tmp___7 = safe_strerror(errcode);
#line 117
        tmp___8 = _("Can\'t read pathname for load map: %s.");
#line 117
        warning(tmp___8, tmp___7);
      } else
#line 115
      if ((new->lm_info)->l_name != (first->lm_info)->l_name) {
#line 117
        tmp___7 = safe_strerror(errcode);
#line 117
        tmp___8 = _("Can\'t read pathname for load map: %s.");
#line 117
        warning(tmp___8, tmp___7);
      }
#line 119
      do_cleanups(old_chain);
#line 120
      goto __Cont;
    }
#line 123
    strncpy(new->so_name, buffer, 511);
#line 124
    new->so_name[511] = (char )'\000';
#line 125
    strcpy(new->so_original_name, new->so_name);
#line 126
    free((void *)buffer);
#line 130
    if (! new->so_name[0]) {
#line 132
      do_cleanups(old_chain);
#line 133
      goto __Cont;
    } else {
#line 130
      tmp___9 = match_main(new->so_name);
#line 130
      if (tmp___9) {
#line 132
        do_cleanups(old_chain);
#line 133
        goto __Cont;
      }
    }
#line 136
    discard_cleanups(old_chain);
#line 137
    new->next = (struct so_list *)0;
#line 138
    *(*link_ptr_ptr) = new;
#line 139
    *link_ptr_ptr = & new->next;
    __Cont: /* CIL Label */ 
#line 63
    prev_lm = lm;
#line 63
    lm = next_lm;
  }
#line 142
  return (1);
}
}
#line 145 "binutils_uaf_4.c"
int main(int argc , char **argv ) 
{ 
  struct so_list **link_ptr ;

  {
#line 148
  svr4_read_so_list(argc, argc - 1, & link_ptr, 1);
#line 149
  return (0);
}
}
