/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 512 "../include/binutils.h"
typedef unsigned long long BFD_HOST_U_64_BIT;
#line 515 "../include/binutils.h"
typedef BFD_HOST_U_64_BIT bfd_vma;
#line 522 "../include/binutils.h"
typedef unsigned char bfd_byte;
#line 9 "binutils_uaf_3.c"
typedef unsigned int CGEN_INSN_INT;
#line 32
struct cgen_insn;
#line 32 "binutils_uaf_3.c"
typedef struct cgen_insn CGEN_INSN;
#line 35
struct cgen_cpu_desc;
#line 35 "binutils_uaf_3.c"
typedef struct cgen_cpu_desc *CGEN_CPU_DESC;
#line 61 "binutils_uaf_3.c"
struct cgen_insn_list {
   struct cgen_insn_list *next ;
   CGEN_INSN const   *insn ;
};
#line 61 "binutils_uaf_3.c"
typedef struct cgen_insn_list CGEN_INSN_LIST;
#line 68 "binutils_uaf_3.c"
struct cgen_cpu_desc {
   int int_insn_p ;
   CGEN_INSN_LIST **dis_hash_table ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 78 "binutils_uaf_3.c"
void bfd_put_bits(int64_t data , void *p , int bits , bool big_p ) 
{ 
  bfd_byte *addr ;
  int i ;
  int bytes ;
  int addr_index ;
  int tmp ;

  {
#line 81
  addr = (bfd_byte *)p;
#line 85
  if (bits % 8 != 0) {
#line 86
    abort();
  }
#line 88
  bytes = bits / 8;
#line 89
  i = 0;
#line 89
  while (i < bytes) {
#line 91
    if (big_p) {
#line 91
      tmp = (bytes - i) - 1;
    } else {
#line 91
      tmp = i;
    }
#line 91
    addr_index = tmp;
#line 93
    *(addr + addr_index) = (bfd_byte )(data & 255L);
#line 94
    data >>= 8;
#line 89
    i ++;
  }
#line 96
  return;
}
}
#line 115
extern int ( /* missing proto */  bfd_get_bits)() ;
#line 99 "binutils_uaf_3.c"
CGEN_INSN_INT cgen_get_insn_value(CGEN_CPU_DESC cd , unsigned char *buf , int length ) 
{ 
  int big_p ;
  int insn_chunk_bitsize ;
  CGEN_INSN_INT value ;
  int i ;
  int bit_index ;
  bfd_vma this_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 104
  value = (CGEN_INSN_INT )0;
#line 106
  if (insn_chunk_bitsize != 0) {
#line 106
    if (insn_chunk_bitsize < length) {
#line 109
      i = 0;
#line 109
      while (i < length) {
#line 114
        bit_index = i;
#line 115
        tmp = bfd_get_bits(buf + bit_index / 8, insn_chunk_bitsize, big_p);
#line 115
        this_value = (bfd_vma )tmp;
#line 116
        value = (CGEN_INSN_INT )((unsigned long long )(value << insn_chunk_bitsize) | this_value);
#line 109
        i += insn_chunk_bitsize;
      }
    } else {
#line 121
      tmp___0 = bfd_get_bits(buf, length, big_p);
#line 121
      value = (CGEN_INSN_INT )tmp___0;
    }
  } else {
#line 121
    tmp___0 = bfd_get_bits(buf, length, big_p);
#line 121
    value = (CGEN_INSN_INT )tmp___0;
  }
#line 124
  return (value);
}
}
#line 129 "binutils_uaf_3.c"
void cgen_put_insn_value(CGEN_CPU_DESC cd , unsigned char *buf , int length , CGEN_INSN_INT value ) 
{ 
  int big_p ;
  int insn_chunk_bitsize ;
  int i ;
  int bit_index ;

  {
#line 138
  if (insn_chunk_bitsize != 0) {
#line 138
    if (insn_chunk_bitsize < length) {
#line 141
      i = 0;
#line 141
      while (i < length) {
#line 145
        bit_index = (length - insn_chunk_bitsize) - i;
#line 146
        bfd_put_bits((int64_t )((bfd_vma )value), (void *)(buf + bit_index / 8), insn_chunk_bitsize,
                     big_p);
#line 147
        value >>= insn_chunk_bitsize;
#line 141
        i += insn_chunk_bitsize;
      }
    } else {
#line 152
      bfd_put_bits((int64_t )((bfd_vma )value), (void *)buf, length, big_p);
    }
  } else {
#line 152
    bfd_put_bits((int64_t )((bfd_vma )value), (void *)buf, length, big_p);
  }
#line 154
  return;
}
}
#line 162
extern int ( /* missing proto */  build_dis_hash_table)() ;
#line 156 "binutils_uaf_3.c"
CGEN_INSN_LIST *cgen_dis_lookup_insn(CGEN_CPU_DESC cd , char const   *buf , CGEN_INSN_INT value ) 
{ 
  unsigned int hash ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 161
  if ((unsigned long )cd->dis_hash_table == (unsigned long )((void *)0)) {
#line 162
    build_dis_hash_table(cd);
  }
#line 164
  if (((int )*((unsigned char *)buf + 0) & 240) == 64) {
#line 164
    tmp___1 = 0;
  } else
#line 164
  if (((int )*((unsigned char *)buf + 0) & 240) == 224) {
#line 164
    tmp___1 = 0;
  } else
#line 164
  if (((int )*((unsigned char *)buf + 0) & 240) == 96) {
#line 164
    tmp___1 = 0;
  } else
#line 164
  if (((int )*((unsigned char *)buf + 0) & 240) == 80) {
#line 164
    tmp___1 = 0;
  } else {
#line 164
    if (((int )*((unsigned char *)buf + 0) & 240) == 112) {
#line 164
      tmp___0 = (int )*((unsigned char *)buf + 0) & 15;
    } else
#line 164
    if (((int )*((unsigned char *)buf + 0) & 240) == 240) {
#line 164
      tmp___0 = (int )*((unsigned char *)buf + 0) & 15;
    } else {
#line 164
      if (((int )*((unsigned char *)buf + 0) & 240) == 48) {
#line 164
        tmp = ((int )*((unsigned char *)buf + 1) & 112) >> 4;
      } else {
#line 164
        tmp = ((int )*((unsigned char *)buf + 1) & 240) >> 4;
      }
#line 164
      tmp___0 = tmp;
    }
#line 164
    tmp___1 = tmp___0;
  }
#line 164
  hash = (unsigned int )(((int )*((unsigned char *)buf + 0) & 240) | tmp___1);
#line 165
  return (*(cd->dis_hash_table + hash));
}
}
#line 168 "binutils_uaf_3.c"
CGEN_INSN const   *cgen_lookup_insn(CGEN_CPU_DESC cd , CGEN_INSN const   *insn , CGEN_INSN_INT insn_int_value ,
                                    unsigned char *insn_bytes_value ) 
{ 
  int length ;
  unsigned char *buf ;
  CGEN_INSN_INT base_insn ;
  void *tmp ;
  CGEN_INSN_LIST const   *insn_list ;
  CGEN_INSN_LIST *tmp___0 ;

  {
#line 178
  if (cd->int_insn_p) {
#line 180
    tmp = malloc((size_t )4);
#line 180
    buf = (unsigned char *)tmp;
#line 181
    cgen_put_insn_value(cd, buf, length, insn_int_value);
#line 182
    base_insn = insn_int_value;
#line 183
    free((void *)buf);
  } else {
#line 187
    buf = insn_bytes_value;
#line 188
    base_insn = cgen_get_insn_value(cd, buf, length);
  }
#line 191
  if (! insn) {
#line 195
    tmp___0 = cgen_dis_lookup_insn(cd, (char const   *)((char *)buf), base_insn);
#line 195
    insn_list = (CGEN_INSN_LIST const   *)tmp___0;
#line 196
    while ((unsigned long )insn_list != (unsigned long )((void *)0)) {
#line 198
      insn = (CGEN_INSN const   *)insn_list->insn;
#line 199
      insn_list = (CGEN_INSN_LIST const   *)insn_list->next;
    }
  }
#line 203
  return ((CGEN_INSN const   *)((void *)0));
}
}
#line 209
extern int ( /* missing proto */  strdup)() ;
#line 206 "binutils_uaf_3.c"
int main(void) 
{ 
  CGEN_CPU_DESC cd ;
  void *tmp ;
  unsigned char *insn_bytes_value ;
  int tmp___0 ;
  int tmp___2 ;

  {
#line 208
  tmp = malloc(sizeof(*cd));
#line 208
  cd = (CGEN_CPU_DESC )tmp;
#line 209
  tmp___0 = strdup("insn_value");
#line 209
  insn_bytes_value = (unsigned char *)tmp___0;
#line 210
  tmp___2 = rand();
#line 210
  if (tmp___2 % 2 == 1) {
#line 210
    cd->int_insn_p = 1;
  } else {
#line 210
    cd->int_insn_p = 0;
  }
#line 211
  cgen_lookup_insn(cd, (CGEN_INSN const   *)((void *)0), (CGEN_INSN_INT )0, insn_bytes_value);
#line 212
  free((void *)insn_bytes_value);
#line 213
  free((void *)cd);
#line 214
  return (0);
}
}
