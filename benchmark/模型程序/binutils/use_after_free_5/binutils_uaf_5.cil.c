/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 9 "binutils_uaf_5.c"
struct attach_command_continuation_args {
   char *args ;
   int from_tty ;
   int async_exec ;
};
#line 60
struct target_ops;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 21 "binutils_uaf_5.c"
extern int ( /* missing proto */  memcpy)() ;
#line 16 "binutils_uaf_5.c"
char *savestring(char const   *ptr , size_t len ) 
{ 
  char *p ;
  void *tmp ;

  {
#line 19
  tmp = malloc(len + 1UL);
#line 19
  p = (char *)tmp;
#line 21
  memcpy(p, ptr, len);
#line 22
  *(p + len) = (char)0;
#line 23
  return (p);
}
}
#line 37
extern int ( /* missing proto */  strlen)() ;
#line 41
extern int ( /* missing proto */  isspace)() ;
#line 52
extern int ( /* missing proto */  strdup)() ;
#line 26 "binutils_uaf_5.c"
static char *strip_bg_char(char const   *args , int *bg_char_p ) 
{ 
  char const   *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 31
  if ((unsigned long )args == (unsigned long )((void *)0)) {
#line 33
    *bg_char_p = 0;
#line 34
    return ((char *)((void *)0));
  } else
#line 31
  if ((int const   )*args == 0) {
#line 33
    *bg_char_p = 0;
#line 34
    return ((char *)((void *)0));
  }
#line 37
  tmp = strlen(args);
#line 37
  p = args + tmp;
#line 38
  if ((int const   )*(p + -1) == 38) {
#line 40
    p --;
#line 41
    while (1) {
#line 41
      if ((unsigned long )p > (unsigned long )args) {
#line 41
        tmp___0 = isspace((int const   )*(p + -1));
#line 41
        if (! tmp___0) {
#line 41
          break;
        }
      } else {
#line 41
        break;
      }
#line 42
      p --;
    }
#line 44
    *bg_char_p = 1;
#line 45
    if ((unsigned long )p != (unsigned long )args) {
#line 46
      tmp___1 = savestring(args, (size_t )(p - args));
#line 46
      return (tmp___1);
    } else {
#line 48
      return ((char *)((void *)0));
    }
  }
#line 51
  *bg_char_p = 0;
#line 52
  tmp___2 = strdup(args);
#line 52
  return ((char *)tmp___2);
}
}
#line 68
extern int ( /* missing proto */  find_attach_target)() ;
#line 79
extern int ( /* missing proto */  target_can_async_p)() ;
#line 91
extern int ( /* missing proto */  attach_command_post_wait)() ;
#line 55 "binutils_uaf_5.c"
void attach_command(char *args , int from_tty ) 
{ 
  int async_exec ;
  struct cleanup *args_chain ;
  struct target_ops *attach_target ;
  int tmp ;
  struct attach_command_continuation_args *a ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 65
  args = strip_bg_char((char const   *)args, & async_exec);
#line 66
  args_chain = make_cleanup((make_cleanup_ftype *)(& free), (void *)args);
#line 68
  tmp = find_attach_target();
#line 68
  attach_target = (struct target_ops *)tmp;
#line 72
  attach_target = (struct target_ops *)((void *)0);
#line 75
  do_cleanups(args_chain);
#line 79
  tmp___2 = target_can_async_p();
#line 79
  if (tmp___2) {
#line 84
    tmp___0 = malloc(sizeof(*a));
#line 84
    a = (struct attach_command_continuation_args *)tmp___0;
#line 85
    tmp___1 = strdup(args);
#line 85
    a->args = (char *)tmp___1;
#line 86
    a->from_tty = from_tty;
#line 87
    a->async_exec = async_exec;
#line 88
    return;
  }
#line 91
  attach_command_post_wait(args, from_tty, async_exec);
#line 92
  return;
}
}
#line 94 "binutils_uaf_5.c"
int main(int argc , char **argv ) 
{ 
  int i ;

  {
#line 96
  i = 1;
#line 96
  while (i < argc) {
#line 97
    attach_command(*(argv + i), i);
#line 96
    i ++;
  }
#line 98
  return (0);
}
}
