/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 512 "../include/binutils.h"
typedef unsigned long long BFD_HOST_U_64_BIT;
#line 517 "../include/binutils.h"
typedef BFD_HOST_U_64_BIT bfd_size_type;
#line 519 "../include/binutils.h"
typedef int bfd_boolean;
#line 524
struct bfd;
#line 524 "../include/binutils.h"
typedef struct bfd bfd;
#line 16 "binutils_uaf_2.c"
struct bfd_target {
   char *name ;
};
#line 16 "binutils_uaf_2.c"
typedef struct bfd_target bfd_target;
#line 31 "binutils_uaf_2.c"
struct bfd {
   char const   *filename ;
   struct bfd_target  const  *xvec ;
   void *iostream ;
   int format ;
   unsigned int opened_once : 1 ;
   unsigned int is_thin_archive : 1 ;
   struct bfd *my_archive ;
   struct bfd *archive_next ;
   struct bfd *archive_head ;
   struct bfd *nested_archives ;
   unsigned int target_defaulted : 1 ;
};
#line 49
struct artdata;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 56 "binutils_uaf_2.c"
extern int ( /* missing proto */  bfd_set_error)() ;
#line 55
extern int ( /* missing proto */  bfd_get_error)() ;
#line 53
extern int ( /* missing proto */  bfd_bread)() ;
#line 60
extern int ( /* missing proto */  strncmp)() ;
#line 46 "binutils_uaf_2.c"
bfd_target const   *bfd_generic_archive_p(bfd *abfd ) 
{ 
  char armag[9] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 53
  tmp___0 = bfd_bread(armag, 8, abfd);
#line 53
  if (tmp___0 != 8) {
#line 55
    tmp = bfd_get_error();
#line 55
    if (tmp != 1) {
#line 56
      bfd_set_error(3);
    }
#line 57
    return ((bfd_target const   *)((void *)0));
  }
#line 60
  tmp___1 = strncmp(armag, "!<thin>\n", 8);
#line 60
  abfd->is_thin_archive = (unsigned int )(tmp___1 == 0);
#line 62
  tmp___2 = strncmp(armag, "!<arch>\n", 8);
#line 62
  if (tmp___2 != 0) {
#line 62
    tmp___3 = strncmp(armag, "!<bout>\n", 8);
#line 62
    if (tmp___3 != 0) {
#line 62
      if (! abfd->is_thin_archive) {
#line 65
        return ((bfd_target const   *)((void *)0));
      }
    }
  }
#line 67
  return (abfd->xvec);
}
}
#line 76
extern int ( /* missing proto */  _bfd_new_bfd)() ;
#line 82
extern int ( /* missing proto */  bfd_find_target)() ;
#line 86
extern int ( /* missing proto */  close)() ;
#line 87
extern int ( /* missing proto */  _bfd_delete_bfd)() ;
#line 93
extern int ( /* missing proto */  strdup)() ;
#line 70 "binutils_uaf_2.c"
bfd *bfd_fopen(char const   *filename , char const   *target , char const   *mode ,
               int fd ) 
{ 
  bfd *nbfd ;
  bfd_target const   *target_vec ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
	MemFix_dump();
#line 76
  tmp = _bfd_new_bfd();
#line 76
  nbfd = (bfd *)tmp;
	MemFix_dump();
#line 77
  if ((unsigned long )nbfd == (unsigned long )((void *)0)) {
#line 79
    return ((bfd *)((void *)0));
  }
#line 82
  tmp___0 = bfd_find_target(target, nbfd);
#line 82
  target_vec = (bfd_target const   *)tmp___0;
#line 83
  if ((unsigned long )target_vec == (unsigned long )((void *)0)) {
#line 85
    if (fd != -1) {
#line 86
      close(fd);
    }
#line 87
    _bfd_delete_bfd(nbfd);
#line 88
    return ((bfd *)((void *)0));
  }
#line 93
  tmp___1 = strdup(filename);
#line 93
  nbfd->filename = (char const   *)tmp___1;
#line 95
  return (nbfd);
}
}
#line 99 "binutils_uaf_2.c"
bfd *bfd_openr(char const   *filename , char const   *target ) 
{ 
  bfd *tmp ;

  {
#line 102
  tmp = bfd_fopen(filename, target, "r", -1);
#line 102
  return (tmp);
}
}
#line 117
extern int ( /* missing proto */  bfd_close)() ;
#line 108
extern int ( /* missing proto */  bfd_read_p)() ;
#line 105 "binutils_uaf_2.c"
bfd_boolean _bfd_archive_close_and_cleanup(bfd *abfd ) 
{ 
  bfd *nbfd ;
  bfd *next ;
  int tmp ;

  {
#line 108
  tmp = bfd_read_p(abfd);
#line 108
  if (tmp) {
#line 108
    if (abfd->format == 2) {
#line 114
      nbfd = abfd->nested_archives;
#line 114
      while (nbfd) {
#line 116
        next = nbfd->archive_next;
#line 117
        bfd_close(nbfd);
#line 114
        nbfd = next;
      }
    }
  }
#line 121
  return (1);
}
}
#line 123 "binutils_uaf_2.c"
static bfd *open_nested_file(char const   *filename , bfd *archive ) 
{ 
  char const   *target ;
  bfd *n_bfd ;

  {
#line 129
  target = (char const   *)((void *)0);
#line 130
  if (! archive->target_defaulted) {
#line 131
    target = (char const   *)(archive->xvec)->name;
  }
#line 132
  n_bfd = bfd_openr(filename, target);
#line 133
  if ((unsigned long )n_bfd != (unsigned long )((void *)0)) {
#line 135
    n_bfd->my_archive = archive;
  }
#line 137
  return (n_bfd);
}
}
#line 146
extern int ( /* missing proto */  filename_cmp)() ;
#line 140 "binutils_uaf_2.c"
static bfd *find_nested_archive(char const   *filename , bfd *arch_bfd ) 
{ 
  bfd *abfd ;
  int tmp ;
  int tmp___0 ;

  {
#line 146
  tmp = filename_cmp(filename, arch_bfd->filename);
#line 146
  if (tmp == 0) {
#line 148
    bfd_set_error(10);
#line 149
    return ((bfd *)((void *)0));
  }
#line 152
  abfd = arch_bfd->nested_archives;
#line 152
  while ((unsigned long )abfd != (unsigned long )((void *)0)) {
#line 156
    tmp___0 = filename_cmp(filename, abfd->filename);
#line 156
    if (tmp___0 == 0) {
#line 157
      return (abfd);
    }
#line 152
    abfd = abfd->archive_next;
  }
#line 159
  abfd = open_nested_file(filename, arch_bfd);
#line 160
  if (abfd) {
#line 162
    abfd->archive_next = arch_bfd->nested_archives;
#line 163
    arch_bfd->nested_archives = abfd;
  }
#line 165
  return (abfd);
}
}
#line 186
extern int ( /* missing proto */  bfd_check_format)() ;
#line 168 "binutils_uaf_2.c"
int main(int argc , char **argv ) 
{ 
  bfd *archive ;
  bfd *nbfd ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 173
  if (argc != 2) {
#line 174
    printf((char const   * __restrict  )"usage: bfdtest1 <archive>%s", "");
#line 174
    exit(1);
  }
#line 176
  archive = bfd_openr((char const   *)*(argv + 0), (char const   *)((void *)0));
#line 177
  if ((unsigned long )archive == (unsigned long )((void *)0)) {
#line 178
    printf((char const   * __restrict  )"no such archive%s", "");
#line 178
    exit(1);
  }
#line 180
  i = 1;
#line 180
  while (i < argc) {
#line 182
    nbfd = find_nested_archive((char const   *)*(argv + i), archive);
#line 183
    printf((char const   * __restrict  )"%d\n", *((int *)nbfd));
#line 180
    i ++;
  }
#line 186
  tmp = bfd_check_format(archive, 2);
#line 186
  if (! tmp) {
#line 188
    bfd_close(archive);
#line 189
    printf((char const   * __restrict  )"bfd_check_format%s", "");
#line 189
  }
#line 192
  _bfd_archive_close_and_cleanup(archive);
#line 194
  bfd_generic_archive_p(archive);
#line 196
  if (archive->format != 0) {
#line 199
    nbfd = archive->nested_archives;
#line 199
    while (nbfd) {
#line 200
      printf((char const   * __restrict  )"%d\n", *((int *)nbfd));
#line 199
      nbfd = nbfd->archive_next;
    }
  }
#line 202
  tmp___0 = bfd_close(archive);
#line 202
  if (! tmp___0) {
#line 203
    printf((char const   * __restrict  )"bfd_close%s", "");
#line 203
  }
#line 205
  return (0);
}
}
