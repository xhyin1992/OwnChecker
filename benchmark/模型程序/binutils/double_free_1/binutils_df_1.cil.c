/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 10 "binutils_df_1.c"
typedef unsigned char bfd_byte;
#line 11 "binutils_df_1.c"
typedef bfd_byte gdb_byte;
#line 12 "binutils_df_1.c"
typedef unsigned long ULONGEST;
#line 14
enum target_xfer_status {
    TARGET_XFER_OK = 1,
    TARGET_XFER_EOF = 0,
    TARGET_XFER_UNAVAILABLE = 2,
    TARGET_XFER_E_IO = -1
} ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 33 "binutils_df_1.c"
void *xrealloc(void *oldmem , size_t size ) 
{ 
  void *newmem ;

  {
#line 38
  if (size == 0UL) {
#line 39
    size = (size_t )1;
  }
#line 40
  if (! oldmem) {
#line 41
    newmem = malloc(size);
  } else {
#line 43
    newmem = realloc(oldmem, size);
  }
#line 44
  if (! newmem) {
#line 45
    exit(1);
  }
#line 47
  return (newmem);
}
}
#line 52
extern int ( /* missing proto */  strncmp)() ;
#line 50 "binutils_df_1.c"
int remote_filename_p(char const   *filename ) 
{ 
  int tmp ;

  {
#line 52
  tmp = strncmp(filename, "remote:", 7);
#line 52
  return (tmp == 0);
}
}
#line 55 "binutils_df_1.c"
static int rs6000_ptrace64(int req , int id , long long addr , int data , void *buf ) 
{ 
  int i ;
  int ret ;
  int tmp___0 ;

  {
#line 58
  i = *((int *)addr);
#line 60
  tmp___0 = rand();
#line 60
  if (tmp___0 % 2 == 1) {
#line 60
    ret = 1;
  } else {
#line 60
    ret = -1;
  }
#line 61
  return (ret);
}
}
#line 64 "binutils_df_1.c"
static gdb_byte *rs6000_ptrace_ldinfo(void) 
{ 
  int pid ;
  int ldi_size ;
  void *ldi ;
  void *tmp ;
  int rc ;

  {
#line 66
  pid = 1;
#line 67
  ldi_size = 1024;
#line 68
  tmp = malloc((size_t )ldi_size);
#line 68
  ldi = tmp;
#line 69
  rc = -1;
#line 71
  while (1) {
#line 73
    rc = rs6000_ptrace64(1, pid, (long long )((unsigned long )ldi), ldi_size, (void *)0);
#line 75
    if (rc != -1) {
#line 76
      break;
    }
#line 79
    ldi_size *= 2;
#line 80
    ldi = xrealloc(ldi, (size_t )ldi_size);
  }
#line 83
  return ((gdb_byte *)ldi);
}
}
#line 86 "binutils_df_1.c"
ULONGEST rs6000_aix_ld_info_to_xml(gdb_byte const   *ldi_buf ) 
{ 
  int i ;

  {
#line 89
  i = (int )*ldi_buf;
#line 90
  return ((ULONGEST )i);
}
}
#line 93 "binutils_df_1.c"
static enum target_xfer_status rs6000_xfer_shared_libraries(gdb_byte const   *writebuf ,
                                                            ULONGEST *xfered_len ) 
{ 
  gdb_byte *ldi_buf ;
  ULONGEST result ;
  struct cleanup *cleanup ;

  {
#line 100
  if (writebuf) {
#line 101
    return ((enum target_xfer_status )-1);
  }
#line 103
  ldi_buf = rs6000_ptrace_ldinfo();
#line 104
  if (! ldi_buf) {
#line 104
    exit(1);
  }
#line 105
  cleanup = make_cleanup((make_cleanup_ftype *)(& free), (void *)ldi_buf);
#line 106
  result = rs6000_aix_ld_info_to_xml((gdb_byte const   *)ldi_buf);
#line 108
  free((void *)ldi_buf);
#line 109
  do_cleanups(cleanup);
#line 111
  if (result == 0UL) {
#line 112
    return ((enum target_xfer_status )0);
  } else {
#line 115
    *xfered_len = result;
#line 116
    return ((enum target_xfer_status )1);
  }
}
}
#line 122
extern int ( /* missing proto */  time)() ;
#line 120 "binutils_df_1.c"
int main(void) 
{ 
  time_t t ;
  int tmp ;
  char buf[10] ;
  int len ;
  gdb_byte *writebuf ;
  ULONGEST *xfered_len ;
  int tmp___1 ;

  {
#line 122
  tmp = time(& t);
#line 122
  srand((unsigned int )tmp);
#line 127
  xfered_len = (ULONGEST *)(& len);
#line 129
  tmp___1 = rand();
#line 129
  if (tmp___1 % 2 == 1) {
#line 129
    writebuf = (gdb_byte *)(buf);
  } else {
#line 129
    writebuf = (gdb_byte *)((void *)0);
  }
#line 131
  rs6000_xfer_shared_libraries((gdb_byte const   *)writebuf, xfered_len);
#line 132
  return (0);
}
}
